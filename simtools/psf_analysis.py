'''
Module to analise psf images (e.g. results from ray tracing simulations).
Main functionalities are: computing centroids, psf containers etc.

Author: Raul R Prado

'''

import logging
from math import sqrt, fabs, pi

import matplotlib.pyplot as plt
import numpy as np

from simtools.util.general import collectKwargs


__all__ = ['PSFImage']

logger = logging.getLogger(__name__)
logger.setLevel(logging.DEBUG)


class PSFImage:
    '''
    Image composed of list of photon positions (2D).

    Load photon list from sim_telarray file and compute centroids, psf containers,
    effective area, as well as plot the image as a 2D histogram.

    Parameters
    ----------
    focalLenght: float
        Focal length of the system in cm, needed to convert quantities from
        cm to deg. If None, getPSF will only work in cm (not in deg).

    Atributtes
    ----------
    effectiveArea: float
        Mirror effective area in cm.

    Methods
    -------
    readSimtelFile(file)
        Read a photon list produced by sim_telarray.
    getPSF(fraction=0.8, unit='cm')
        Compute and return a PSF container.
    getEffecticeArea()
        Return effective area under the condition that total area was set given.
    plotImage(**kwargs)
        Plot image as a 2D histogram
    plotIntegral(**kwargs)
        Plot cumulative intensity as a function containing fraction.
    '''
    def __init__(self, focalLength=None, totalScatteredArea=None):
        self._photonPosX = list()
        self._photonPosY = list()
        self._centroidX = None
        self._centroidY = None
        self._totalArea = totalScatteredArea
        self._storedPSF = dict()
        if focalLength is not None:
            self._cmToDeg = 180. / pi / focalLength
            self._hasFocalLength = True
        else:
            self._hasFocalLength = False

    def readSimtelFile(self, file):
        '''
        Read photon list file generated by sim_telarray and store the photon positions (2D)

        Parameters
        ----------
        file: str
            Name of sim_telarray file with photon list.

        Raises
        ------
        RuntimeError
            If photon positions X and Y are not compatible or are empty

        '''
        logger.info('Reading SimtelFile {}'.format(file))
        self._totalPhotons = 0
        with open(file, 'r') as f:
            for line in f:
                self._processSimtelLine(line)

        if not self._isPhotonPositionsOK():
            msg = 'Problems reading Simtel file - invalid data'
            logger.error(msg)
            raise RuntimeError(msg)

        self._centroidX = np.mean(self._photonPosX)
        self._centroidY = np.mean(self._photonPosY)
        self._numberOfDetectedPhotons = len(self._photonPosX)
        self._effectiveArea = self._numberOfDetectedPhotons * self._totalArea / self._totalPhotons
        logger.warning('effArea has to be removed - only added temporarily for compatibilty')
        self.effArea = self._effectiveArea

    def _isPhotonPositionsOK(self):
        '''
        Verify if the photon positions are ok.

        Returns
        -------
        bool
            True if photon positions are ok, False if they are not
        '''
        cond1 = len(self._photonPosX) != 0
        cond2 = len(self._photonPosY) != 0
        cond3 = len(self._photonPosX) == len(self._photonPosY)
        return cond1 and cond2 and cond3

    def _processSimtelLine(self, line):
        '''
        Supporting function to readSimtelFile.

        Parameters
        ----------
        line: str
            A line from the photon list file generated by sim_telarray
        '''
        words = line.split()
        if 'falling on an area of' in line:
            self._totalPhotons += int(words[4])
            totalAreaInFile = float(words[14])
            if self._totalArea is None:
                self._totalArea = totalAreaInFile
            elif totalAreaInFile != self._totalArea:
                logger.warning(
                    'Conflicting value of the total area found'
                    ' {} != {}'.format(self._totalArea, totalAreaInFile) +
                    ' - Keeping the original value'
                )
            else:
                # Do nothing - Keep the original value of _totalArea
                pass
        elif '#' in line or len(words) == 0:
            # Skipping comments
            pass
        else:
            # Storing photon position from cols 2 and 3
            self._photonPosX.append(float(words[2]))
            self._photonPosY.append(float(words[3]))

    def getEffectiveArea(self):
        if '_effectiveArea' in self.__dict__ and self._effectiveArea is not None:
            return self._effectiveArea
        else:
            logger.error('Effective Area could not be calculated')
            return None

    def getPSF(self, fraction=0.8, unit='cm'):
        if unit == 'deg' and not self._hasFocalLength:
            logger.error('PSF cannot be computed in deg because focal length is not set')
            return None
        if fraction not in self._storedPSF.keys():
            self._computePSF(fraction)
        unitFactor = 1 if unit == 'cm' else self._cmToDeg
        return self._storedPSF[fraction] * unitFactor

    def _computePSF(self, fraction):
        self._storedPSF[fraction] = self._findPSF(fraction)

    def _findPSF(self, fraction):
        logger.debug('Finding PSF for fraction = {}'.format(fraction))

        xPos2 = [i**2 for i in self._photonPosX]
        yPos2 = [i**2 for i in self._photonPosY]
        xSig = sqrt(np.mean(xPos2) - self._centroidX**2)
        ySig = sqrt(np.mean(yPos2) - self._centroidY**2)
        rSig = sqrt(xSig**2 + ySig**2)

        numberTarget = fraction * self._numberOfDetectedPhotons
        rad = 1.5 * rSig
        number0 = self._sumPhotonsInRadius(rad)
        A = 0.5 * sqrt(rad * rad / number0)
        delta = number0 - numberTarget
        nIter = 0
        foundRadius = False
        while not foundRadius and nIter < 100:
            nIter += 1
            dr = -delta * A / sqrt(numberTarget)
            while rad + dr < 0:
                dr *= 0.5
            rad += dr
            number = self._sumPhotonsInRadius(rad)
            delta = number - numberTarget
            foundRadius = fabs(delta) < self._numberOfDetectedPhotons / 1000.

        if foundRadius:
            return 2 * rad
        else:
            logger.warning('Could not find PSF efficiently')
            psf = self._findPSFByScanning(numberTarget, rSig)
            return psf

    def _findPSFByScanning(self, numberTarget, rSig):
        logger.debug('Finding PSF by scanning')

        def scan(dr, radMin, radMax):
            r0, r1 = radMin, radMin + dr
            s0, s1 = 0, 0
            foundRadius = False
            while not foundRadius:
                s0, s1 = self._sumPhotonsInRadius(r0), self._sumPhotonsInRadius(r1)
                if s0 < numberTarget and s1 > numberTarget:
                    foundRadius = True
                    break
                if r1 > radMax:
                    break
                r0 += dr
                r1 += dr
            if foundRadius:
                return (r0 + r1) / 2, r0, r1
            else:
                logging.error('Could not find PSF by scanning')
                return 0, radMin, radMax

        # Step 0
        rad, radMin, radMax = scan(0.1 * rSig, 0, 4 * rSig)
        # Step 1
        rad, radMin, radMax = scan(0.005 * rSig, radMin, radMax)
        return rad

    def _sumPhotonsInRadius(self, radius):
        n = 0
        for x, y in zip(self._photonPosX, self._photonPosY):
            d2 = (x - self._centroidX)**2 + (y - self._centroidY)**2
            n += 1 if d2 < radius**2 else 0
        return n

    def plotImage(self, **kwargs):
        ''' kwargs for histogram: image_*
            kwargs for PSF circle: psf_*
        '''
        ax = plt.gca()
        fac = 1
        xToPlot = fac*np.array(self._photonPosX) - fac*self._centroidX
        yToPlot = fac*np.array(self._photonPosY) - fac*self._centroidY

        kwargs = setDefaultKwargs(
            kwargs,
            image_bins=80,
            image_cmap=plt.cm.gist_heat_r,
            psf_color='k',
            psf_fill=False,
            psf_lw=2,
            psf_ls='--'
        )
        kwargsForImage = collectKwargs('image', kwargs)
        kwargsForPSF = collectKwargs('psf', kwargs)

        ax.hist2d(xToPlot, yToPlot, **kwargsForImage)

        circle = plt.Circle((0, 0), self.getPSF(0.8) / 2, **kwargsForPSF)
        ax.add_artist(circle)

    def plotIntegral(self, **kwargs):
        ''' kwargs for histogram: image_*
            kwargs for PSF circle: psf_*
        '''
        ax = plt.gca()
        kwargs = setDefaultKwargs(kwargs, color='k', marker='o')

        radiusAll = np.linspace(0, 1.6 * self.getPSF(0.8), 30)
        intensity = list()
        for rad in radiusAll:
            intensity.append(self._sumPhotonsInRadius(rad) / self._numberOfDetectedPhotons)

        ax.plot(radiusAll, intensity, **kwargs)

# end of PSFImage
