import astropy.units as u
import matplotlib.patches as mpatches
import numpy as np
from astropy.table import QTable
from matplotlib import pyplot as plt
from matplotlib.collections import PatchCollection

from simtools import io_handler
from simtools.layout.layout_array import LayoutArray
from simtools.visualization import legend_handlers as leg_h


class LayoutArrayBuilder:
    """
    Manage the array layout. It provides methods to create and plot a LayoutArray.
    """

    def __init__(self):
        """Initialize LayoutArrayBuilder."""
        self.io_handler = io_handler.IOHandler()

    def plot_array(self, telescopes, rotate_angle=0):
        """
        Plot the array of telescopes.

        Parameters
        ----------
        telescopes: dict
            Dictionary with the telescope position and names.
        rotate_angle:
            Angle to rotate the plot. For rotate_angle = 0 the X-axis points towards the east, and\
            the Y-axis points towards the North.

        Returns
        -------
        plt.figure
            Instance of plt.figure with the array of telescopes plotted.

        """
        fig, ax = plt.subplots(1)
        legend_objects = list()
        legend_labels = list()
        tel_counters = {"LST": 0, "MST": 0, "SST": 0}
        if rotate_angle != 0:
            telescopes["pos_x"], telescopes["pos_y"] = self._rotate(
                rotate_angle, telescopes["pos_x"], telescopes["pos_y"]
            )

        size_factor = max(np.max(telescopes["pos_x"]), np.max(telescopes["pos_y"])) / (300.0 * u.m)
        fontsize = 12
        for tel_name_now in telescopes["telescope_name"]:
            for tel_type in tel_counters.keys():
                if tel_type in tel_name_now:
                    tel_counters[tel_type] += 1

        if tel_counters["LST"] > 0:
            legend_objects.append(leg_h.LSTObject())
            legend_labels.append("LST ({})".format(tel_counters["LST"]))
        if tel_counters["MST"] > 0:
            legend_objects.append(leg_h.MSTObject())
            legend_labels.append("MST ({})".format(tel_counters["MST"]))
        if tel_counters["SST"] > 0:
            legend_objects.append(leg_h.SSTObject())
            legend_labels.append("SST ({})".format(tel_counters["SST"]))
            fontsize = 5

        patches = []
        for i_tel in range(len(telescopes)):
            patches.append(
                self._get_telescope_patch(
                    telescopes[i_tel]["telescope_name"][:3],
                    telescopes[i_tel]["pos_x"],
                    telescopes[i_tel]["pos_y"],
                    telescopes[i_tel]["radius"] * size_factor,
                )
            )
            ax.text(
                telescopes[i_tel]["pos_x"].value,
                telescopes[i_tel]["pos_y"].value + telescopes[i_tel]["radius"].value,
                telescopes[i_tel]["telescope_name"],
                horizontalalignment="center",
                verticalalignment="bottom",
                fontsize=fontsize,
            )

        plt.gca().add_collection(PatchCollection(patches, match_original=True))

        legend_handler_map = {
            leg_h.LSTObject: leg_h.LSTHandler(),
            leg_h.MSTObject: leg_h.MSTHandler(),
            leg_h.SSTObject: leg_h.SSTHandler(),
        }

        x_title = "East [m]"
        y_title = "North [m]"
        plt.axis("square")
        plt.grid(True)
        plt.gca().set_axisbelow(True)
        plt.xlabel(x_title, fontsize=18, labelpad=0)
        plt.ylabel(y_title, fontsize=18, labelpad=0)
        plt.tick_params(axis="both", which="major", labelsize=15)

        plt.legend(
            legend_objects,
            legend_labels,
            handler_map=legend_handler_map,
            prop={"size": 11},
            loc="upper left",
        )

        plt.tight_layout()

        return fig

    def telescope_layout_file_to_dict(self, file_name):
        """
        Read the telescope layout from ECSV layout file and returns a dictionary with the x, y, z \
        positions and the radius.
        Note: file_name is usually generated by self.export_telescope_list.

        Parameters
        ----------
        file_name: str
            Name of the ecsv file with telescope layout.

        Returns
        -------
        dict
            Dictionary with the telescope layout information.
        """

        telescopes = QTable.read(file_name)
        telescopes["radius"] = [
            float(telescopes.meta["corsika_sphere_radius"][tel_name_now[:3]].split()[0])
            for tel_name_now in telescopes["telescope_name"]
        ]
        telescopes["radius"].unit = u.Unit(
            telescopes.meta["corsika_sphere_radius"]["LST"].split()[1]
        )

        return telescopes

    def _get_telescope_patch(self, name, x, y, radius):
        """
        Collect the patch of one telescope to be plotted by self.plot_array.

        Parameters
        ----------
        name: str
            Name of the telescope (type).
        x: astropy.units.m
            X position of the telescope in meters.
        y: astropy.units.m
            Y position of the telescope in meters.
        radius: astropy.units.m
            Radius of the telescope sphere in meters.

        Returns
        -------
        patch
            Instance of mpatches.Circle.
        """

        valid_name = LayoutArray.get_telescope_type(name)
        fill_flag = False
        if valid_name == "MST":
            fill_flag = True
        colors = {"LST": "darkorange", "MST": "dodgerblue", "SST": "black"}
        patch = mpatches.Circle(
            (x.value, y.value), radius=radius.value, fill=fill_flag, color=colors[valid_name]
        )
        return patch

    def _rotate(self, rotation_angle, x, y):
        """
        Rotate x and y by the rotation angle given in rotation_angle.
        The function returns the rotated x and y values.
        Notice that rotation_angle must be given in degrees!

        Parameters
        ----------
        rotation_angle
        x: numpy.array of float
            X positions of the telescopes in meters.
        y: numpy.array of float
            Y positions of the telescopes in meters.

        Returns
        -------
        2-tuple of numpy.Array of float
            X and Y positions of the rotated telescopes positions.

        """
        if not isinstance(x, type(y)):
            raise RuntimeError("x and y are not the same type! " "Cannot perform transformation.")
        if not isinstance(x, list):
            x_list, y_list = self._rotate(rotation_angle, [x], [y])
            return x_list[0], y_list[0]

        if len(x) != len(y):
            raise RuntimeError(
                "Cannot perform coordinate transformation " "when x and y have different lengths."
            )
        x_trans, y_trans = list(), list()
        rotate_angle = np.deg2rad(rotation_angle)

        for x_now, y_now in zip(x, y):
            x_trans.append(x_now * np.cos(rotate_angle) + y_now * np.sin(rotate_angle))
            y_trans.append((-1) * x_now * np.sin(rotate_angle) + y_now * np.cos(rotate_angle))

        return x_trans, y_trans
