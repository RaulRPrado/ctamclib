#!/usr/bin/python3

"""
    Summary
    -------
    This applications tunes the parameters mirror_reflection_random_angle, \
    mirror_align_random_horizontal and mirror_align_random_vertical using \
    cumulative PSF measurement.

    The telescope zenith angle and the source distance can be set by command line arguments.

    The measured cumulative PSF should be provided by using the command line argument data. \
    A file name is expected, in which the file should contain 3 columns: radial distance in mm, \
    differential value of photon intensity and its integral value.

    The tuning is performed through a random search. A number of random combination of the \
    parameters are tested and the best ones are selected based on the minimum value of \
    the Root Mean Squared Deviation between data and simulations. The range in which the \
    parameter are drawn uniformly are defined based on the previous value on the telescope model.

    The assumption are:

    a) mirror_align_random_horizontal and mirror_align_random_vertical are the same.

    b) mirror_align_random_horizontal/vertical have no dependence on the zenith angle.

    One example of the plot generated by this applications are shown below.

    .. _tune_psf_plot:
    .. image::  docs/source/images/tune_psf.png
      :width: 49 %

    Command line arguments
    ----------------------
    site (str, required)
        North or South.
    telescope (str, required)
        Telescope model name (e.g. LST-1, SST-D, ...).
    model_version (str, optional)
        Model version (default="Current").
    src_distance (float, optional)
        Source distance in km (default=10).
    zenith (float, optional)
        Zenith angle in deg (default=20).
    data (str, optional)
        Name of the data file with the measured cumulative PSF.
    plot_all (activation mode, optional)
        If activated, plots will be generated for all values tested during tuning.
    fixed (activation mode, optional)
        Keep the first entry of mirror_reflection_random_angle fixed.
    test (activation mode, optional)
        If activated, application will be faster by simulating fewer photons.
    verbosity (str, optional)
        Log level to print (default=INFO).

    Example
    -------
    LST-1 Prod5

    Runtime around 5 min.

    .. code-block:: console

        python applications/tune_psf.py --site North --telescope LST-1 \
            --model_version prod5 --data PSFcurve_data_v2.txt --plot_all
"""

import logging
from collections import OrderedDict

import astropy.units as u
import matplotlib.pyplot as plt
import numpy as np
from matplotlib.backends.backend_pdf import PdfPages

import simtools.config as cfg
import simtools.io_handler as io
import simtools.util.commandline_parser as argparser
import simtools.util.general as gen
from simtools import visualize
from simtools.model.telescope_model import TelescopeModel
from simtools.ray_tracing import RayTracing
from simtools.util.model import splitSimtelParameter


def loadData(datafile):
    dType = {"names": ("Radius [cm]", "Cumulative PSF"), "formats": ("f8", "f8")}
    data = np.loadtxt(datafile, dtype=dType, usecols=(0, 2))
    data["Radius [cm]"] *= 0.1
    data["Cumulative PSF"] /= np.max(np.abs(data["Cumulative PSF"]))
    return data


def main():

    parser = argparser.CommandLineParser(
        description=(
            "Tune mirror_reflection_random_angle, mirror_align_random_horizontal "
            "and mirror_align_random_vertical using cumulative PSF measurement."
        )
    )
    parser.initialize_telescope_model_arguments()
    parser.add_argument(
        "--src_distance",
        help="Source distance in km (default=10)",
        type=float,
        default=10,
    )
    parser.add_argument("--zenith", help="Zenith angle in deg (default=20)", type=float, default=20)
    parser.add_argument(
        "--data", help="Data file name with the measured PSF vs radius [cm]", type=str
    )
    parser.add_argument(
        "--plot_all",
        help=(
            "On: plot cumulative PSF for all tested combinations, "
            "Off: plot it only for the best set of values"
        ),
        action="store_true",
    )
    parser.add_argument(
        "--fixed",
        help=("Keep the first entry of mirror_reflection_random_angle fixed."),
        action="store_true",
    )
    parser.initialize_default_arguments(add_workflow_config=False)

    args = parser.parse_args()
    label = "tune_psf"
    cfg.setConfigFileName(args.configFile)

    logger = logging.getLogger()
    logger.setLevel(gen.getLogLevelFromUser(args.logLevel))

    # Output directory to save files related directly to this app
    outputDir = io.getOutputDirectory(cfg.get("outputLocation"), label, dirType="application-plots")

    telModel = TelescopeModel(
        site=args.site,
        telescopeModelName=args.telescope,
        modelVersion=args.model_version,
        label=label,
    )
    # If we want to start from values different than the ones currently in the model:
    # align = 0.0046
    # parsToChange = {
    #     'mirror_reflection_random_angle': '0.0075 0.125 0.0037',
    #     'mirror_align_random_horizontal': f'{align} 28 0 0',
    #     'mirror_align_random_vertical': f'{align} 28 0 0',
    # }
    # telModel.changeMultipleParameters(**parsToChange)

    allParameters = list()

    def addParameters(
        mirror_reflection, mirror_align, mirror_reflection_fraction=0.15, mirror_reflection_2=0.035
    ):
        """
        Transform the parameters to the proper format and add a new set of
        parameters to the allParameters list.
        """
        pars = dict()
        mrra = "{:.4f},{:.2f},{:.4f}".format(
            mirror_reflection, mirror_reflection_fraction, mirror_reflection_2
        )
        pars["mirror_reflection_random_angle"] = mrra
        mar = "{:.4f},28.,0.,0.".format(mirror_align)
        pars["mirror_align_random_horizontal"] = mar
        pars["mirror_align_random_vertical"] = mar
        allParameters.append(pars)

    # Grabbing the previous values of the parameters from the tel model.
    #
    # mrra -> mirror reflection random angle (first entry of mirror_reflection_random_angle)
    # mfr -> mirror fraction random (second entry of mirror_reflection_random_angle)
    # mrra2 -> mirror reflection random angle 2 (third entry of mirror_reflection_random_angle)
    # mar -> mirror align random (first entry of mirror_align_random_horizontal/vertical)

    rawPar = telModel.getParameter("mirror_reflection_random_angle")["Value"]
    splitPar = splitSimtelParameter(rawPar)
    mrra_0 = splitPar[0]
    mfr_0 = splitPar[1]
    mrra2_0 = splitPar[2]

    rawPar = telModel.getParameter("mirror_align_random_horizontal")["Value"]
    mar_0 = splitSimtelParameter(rawPar)[0]

    logger.debug(
        "Previous parameter values: \n"
        "MRRA = " + str(mrra_0) + "\n"
        "MRF = " + str(mfr_0) + "\n"
        "MRRA2 = " + str(mrra2_0) + "\n"
        "MAR = " + str(mar_0) + "\n"
    )

    if args.fixed:
        logger.debug("fixed=True - First entry of mirror_reflection_random_angle is kept fixed.")

    # Drawing parameters randonly
    # Range around the previous values are hardcoded
    # Number of runs is hardcoded
    N_RUNS = 50
    for _ in range(N_RUNS):
        mrra_range = 0.004 if not args.fixed else 0
        mrf_range = 0.1
        mrra2_range = 0.03
        mar_range = 0.005
        mrra = np.random.uniform(max(mrra_0 - mrra_range, 0), mrra_0 + mrra_range)
        mrf = np.random.uniform(max(mfr_0 - mrf_range, 0), mfr_0 + mrf_range)
        mrra2 = np.random.uniform(max(mrra2_0 - mrra2_range, 0), mrra2_0 + mrra2_range)
        mar = np.random.uniform(max(mar_0 - mar_range, 0), mar_0 + mar_range)
        addParameters(mrra, mar, mrf, mrra2)

    # Loading measured cumulative PSF
    dataToPlot = OrderedDict()
    if args.data is not None:
        dataFile = cfg.findFile(args.data)
        dataToPlot["measured"] = loadData(dataFile)
        radius = dataToPlot["measured"]["Radius [cm]"]

    # Preparing figure name
    plotFileName = "_".join((label, telModel.name + ".pdf"))
    plotFile = outputDir.joinpath(plotFileName)
    pdfPages = PdfPages(plotFile)

    def calculateRMSD(data, sim):
        """
        Calculates the Root Mean Squared Deviation to be used
        as metric to find the best parameters.
        """
        return np.sqrt(np.mean((data - sim) ** 2))

    def runPars(pars, plot=True):
        """
        Runs the tuning for one set of parameters, add a plot to the pdfPages
        (if plot=True) and returns the RMSD and the D80.
        """
        telModel.changeMultipleParameters(**pars)

        ray = RayTracing.fromKwargs(
            telescopeModel=telModel,
            sourceDistance=args.src_distance * u.km,
            zenithAngle=args.zenith * u.deg,
            offAxisAngle=[0.0 * u.deg],
        )

        ray.simulate(test=args.test, force=True)
        ray.analyze(force=True, useRX=False)

        # Plotting cumulative PSF
        im = ray.images()[0]
        d80 = im.getPSF()

        # Simulated cumulative PSF
        dataToPlot["simulated"] = im.getCumulativeData(radius * u.cm)

        rmsd = calculateRMSD(
            dataToPlot["measured"]["Cumulative PSF"], dataToPlot["simulated"]["Cumulative PSF"]
        )

        if plot:
            fig = visualize.plot1D(
                dataToPlot,
                plotDifference=True,
                noMarkers=True,
            )
            ax = fig.get_axes()[0]
            ax.set_ylim(0, 1.05)
            ax.set_title(
                "refl_rnd={}, align_rnd={}".format(
                    pars["mirror_reflection_random_angle"], pars["mirror_align_random_vertical"]
                )
            )

            ax.text(
                0.8,
                0.3,
                "D80 = {:.3f} cm\nRMSD = {:.4f}".format(d80, rmsd),
                verticalalignment="center",
                horizontalalignment="center",
                transform=ax.transAxes,
            )
            plt.tight_layout()
            pdfPages.savefig(fig)
            plt.clf()

        return d80, rmsd

    # Running the tuning for all parameters in allParameters
    # and storing the best parameters in best_pars
    min_rmsd = 100
    for pars in allParameters:
        _, rmsd = runPars(pars, plot=args.plot_all)
        if rmsd < min_rmsd:
            min_rmsd = rmsd
            best_pars = pars

    # Rerunnig and plotting the best pars
    runPars(best_pars, plot=True)

    plt.close()
    pdfPages.close()

    # Printing the results
    print("Best parameters:")
    for par, value in best_pars.items():
        print("{} = {}".format(par, value))


if __name__ == "__main__":
    main()
