#!/usr/bin/python3

"""
    Summary
    -------
    This application simulates the cumulative PSF and compare with data (if available).

    The telescope zenith angle and the source distance can be set by command line arguments.

    The measured cumulative PSF should be provided by using the command line argument data. \
    A file name is expected, in which the file should contains 3 columns: radial distance in mm, \
    differential value of photon intensity and its integral value.

    The MC model can be changed by providing a yaml file with the new parameter values using \
    the argument pars (see example below).

    Examples of the plots generated by this applications are shown below. On the left, \
    the cumulative PSF and on the right, the simulated PSF image.

    .. _tune_psf_plot:
    .. image::  images/
      :width: 49 %

    Command line arguments
    ----------------------
    site (str, required)
        North or South.
    telescope (str, required)
        Telescope model name (e.g. LST-1, SST-D, ...).
    model_version (str, optional)
        Model version (default=prod4).
    src_distance (float, optional)
        Source distance in km (default=10).
    zenith (float, optional)
        Zenith angle in deg (default=20).
    data (str, optional)
        Name of the data file with the measured cumulative PSF.
    pars (str, optional)
        Yaml file with the new model parameters to replace the default ones.
    test (activation mode, optional)
        If activated, application will be faster by simulating fewer photons.
    verbosity (str, optional)
        Log level to print (default=INFO).

    Example
    -------
    LST-1 Prod5

    Runtime < 1 min.

    First, create an yml file named lst_pars.yml with the following content:

    .. code-block:: yaml

        mirror_reflection_random_angle: '0.0075,0.15,0.035'
        mirror_align_random_horizontal: '0.0040,28.,0.0,0.0'
        mirror_align_random_vertical: '0.0040,28.,0.0,0.0'

    And the run:

    .. code-block:: console

        python applications/compare_cumulative_psf.py --site North --telescope LST-1 --model_version prod4 --pars lst_pars.yml --data PSFcurve_data_v2.txt

    .. todo::

        * Change default model to default (after this feature is implemented in db_handler)
"""

import yaml
import logging
import argparse
import numpy as np
import matplotlib.pyplot as plt
from collections import OrderedDict
from matplotlib.backends.backend_pdf import PdfPages

import astropy.units as u

import simtools.io_handler as io
import simtools.util.general as gen
import simtools.config as cfg
from simtools.ray_tracing import RayTracing
from simtools.model.telescope_model import TelescopeModel
from simtools import visualize
from simtools.util.model import splitSimtelParameter


def loadData(datafile):
    dType = {"names": ("Radius [cm]", "Relative intensity"), "formats": ("f8", "f8")}
    data = np.loadtxt(datafile, dtype=dType, usecols=(0, 2))
    data["Radius [cm]"] *= 0.1
    data["Relative intensity"] /= np.max(np.abs(data["Relative intensity"]))
    return data


if __name__ == "__main__":

    parser = argparse.ArgumentParser(
        description=(
            "Tune mirror_reflection_random_angle, mirror_align_random_horizontal "
            "and mirror_align_random_vertical using cumulative PSF measurement."
        )
    )
    parser.add_argument("-s", "--site", help="North or South", type=str, required=True)
    parser.add_argument(
        "-t",
        "--telescope",
        help="Telescope model name (e.g. MST-FlashCam-D, LST-1)",
        type=str,
        required=True,
    )
    parser.add_argument(
        "-m",
        "--model_version",
        help="Model version (default=prod4)",
        type=str,
        default="prod4",
    )
    parser.add_argument(
        "--src_distance",
        help="Source distance in km (default=10)",
        type=float,
        default=10,
    )
    parser.add_argument(
        "--zenith", help="Zenith angle in deg (default=20)", type=float, default=20
    )
    parser.add_argument(
        "--data", help="Data file name with the measured PSF vs radius [cm]", type=str
    )
    parser.add_argument(
        "--plot_all",
        help=(
            "On: plot cumulative PSF for all tested combinations, "
            "Off: plot it only for the best set of values"
        ),
        action="store_true",
    )
    parser.add_argument(
        "--test",
        help="Test option will be faster by simulating fewer photons.",
        action="store_true",
    )
    parser.add_argument(
        "-v",
        "--verbosity",
        dest="logLevel",
        action="store",
        default="info",
        help="Log level to print (default is INFO)",
    )

    args = parser.parse_args()
    label = "tune_psf"

    logger = logging.getLogger()
    logger.setLevel(gen.getLogLevelFromUser(args.logLevel))

    # Output directory to save files related directly to this app
    outputDir = io.getApplicationOutputDirectory(cfg.get("outputLocation"), label)

    telModel = TelescopeModel(
        site=args.site,
        telescopeModelName=args.telescope,
        modelVersion=args.model_version,
        label=label,
    )

    allParameters = list()

    def addParameters(
        mirror_reflection,
        mirror_align,
        mirror_reflection_fraction=0.15,
        mirror_reflection_2=0.035
    ):
        """
        Transform the parameters to the proper format and add a new set of
        parameters to the allParameters list.
        """
        pars = dict()
        mrra = "{:.4f},{:.2f},{:.4f}".format(
            mirror_reflection,
            mirror_reflection_fraction,
            mirror_reflection_2
        )
        pars["mirror_reflection_random_angle"] = mrra
        mar = "{:.4f},28.,0.,0.".format(mirror_align)
        pars["mirror_align_random_horizontal"] = mar
        pars["mirror_align_random_vertical"] = mar
        allParameters.append(pars)

    # Grabbing the previous values of the parameters from the tel model.
    #
    # mrra -> mirror reflection random angle (first entry of mirror_reflection_random_angle)
    # mfr -> mirror fraction random (second entry of mirror_reflection_random_angle)
    # mrra2 -> mirror reflection random angle 2 (third entry of mirror_reflection_random_angle)
    # mar -> mirror align random (first entry of mirror_align_random_horizontal/vertical)

    rawPar = telModel.getParameter("mirror_reflection_random_angle")["Value"]
    splitPar = splitSimtelParameter(rawPar)
    mrra_0 = splitPar[0]
    mfr_0 = splitPar[1]
    mrra2_0 = splitPar[2]

    rawPar = telModel.getParameter("mirror_align_random_horizontal")["Value"]
    mar_0 = splitSimtelParameter(rawPar)[0]

    logger.debug(
        "Previous parameter values: \n"
        "MRRA = " + str(mrra_0) + "\n"
        "MRF = " + str(mfr_0) + "\n"
        "MRRA2 = " + str(mrra2_0) + "\n"
        "MAR = " + str(mar_0) + "\n"
    )

    # Drawing parameters randonly
    # Range around the previous values are hardcoded
    N_RUNS = 40
    for _ in range(N_RUNS):
        mrra = np.random.uniform(mrra_0 - 0.15, mrra_0 + 0.15)
        mrf = np.random.uniform(mfr_0 - 0.05, mfr_0 + 0.05)
        mrra2 = np.random.uniform(mrra2_0 - 0.002, mrra2_0 + 0.004)
        mar = np.random.uniform(mar_0 - 0.1, mar_0 + 0.1)
        addParameters(mrra, mar, mrf, mrra2)

    # Loading measured cumulative PSF
    dataToPlot = OrderedDict()
    if args.data is not None:
        dataFile = cfg.findFile(args.data)
        dataToPlot["measured"] = loadData(dataFile)
        radius = dataToPlot["measured"]["Radius [cm]"]

    # Preparing figure name
    plotFileName = "_".join((
        label, telModel.name + ".pdf"
    ))
    plotFile = outputDir.joinpath(plotFileName)
    pdfPages = PdfPages(plotFile)

    def calculateRMSD(data, sim):
        """
        Calculates the Root Mean Squared Deviation to be used
        as metric to find the best parameters.
        """
        return np.sqrt(np.mean((data - sim)**2))

    def runPars(pars, plot=True):
        """
        Runs the tuning for one set of parameters, add a plot to the pdfPages
        (if plot=True) and returns the RMSD and the D80.
        """
        telModel.changeMultipleParameters(**pars)

        ray = RayTracing.fromKwargs(
            telescopeModel=telModel,
            sourceDistance=args.src_distance * u.km,
            zenithAngle=args.zenith * u.deg,
            offAxisAngle=[0.0 * u.deg],
        )

        ray.simulate(test=args.test, force=True)
        ray.analyze(force=True)

        # Plotting cumulative PSF
        im = ray.images()[0]
        d80 = im.getPSF()

        # Simulated cumulative PSF
        dataToPlot["simulated"] = im.getCumulativeData(radius * u.cm)

        rmsd = calculateRMSD(
            dataToPlot["measured"]["Relative intensity"],
            dataToPlot["simulated"]["Relative intensity"]
        )

        if plot:
            fig = visualize.plot1D(dataToPlot)
            ax = plt.gca()
            ax.set_ylim(0, 1.05)
            ax.set_title("refl_rnd={}, align_rnd={}".format(
                pars["mirror_reflection_random_angle"],
                pars["mirror_align_random_vertical"]
            ))

            ax.legend(loc='lower right')

            ax.text(
                0.8,
                0.5,
                "D80 = {:.3f} cm\nRMSD = {:.4f}".format(d80, rmsd),
                verticalalignment="center",
                horizontalalignment="center",
                transform=ax.transAxes,
            )
            plt.tight_layout()
            pdfPages.savefig(fig)
            plt.clf()

        return d80, rmsd

    # Running the tuning for all parameters in allParameters
    # and storing the best parameters in best_pars
    min_rmsd = 100
    for pars in allParameters:
        _, rmsd = runPars(pars, plot=args.plot_all)
        if rmsd < min_rmsd:
            min_rmsd = rmsd
            best_pars = pars

    # Rerunnig and plotting the best pars
    runPars(best_pars, plot=True)

    plt.close()
    pdfPages.close()

    # Printing the results
    print('Best parameters:')
    for par, value in best_pars.items():
        print("{} = {}".format(par, value))
